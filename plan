# PROJECT: GILMA - A Versioned File Synchronization System

**Objective:** Build a simplified, networked, version-controlled file storage system inspired by Git.

---

### Core Components:

1.  **The `gilma-server`:** A central server application that stores all file data and history. It will listen for commands from the client.
2.  **The `gilma` client:** A command-line tool (an evolution of `kannadi`) that communicates with the server.

---

### Phase 1: The Naive Server & Push Command

**Goal:** Get files from the client to the server.

1.  **Server: Basic File Storage:**
    -   Create a new `gilma-server` project.
    -   It will listen for TCP connections.
    -   It will not store versions yet. It will have a simple "storage" directory.
    -   When a client connects and "pushes", the server will simply save the received files into its storage, mirroring the client's structure.

2.  **Client: The `push` Command:**
    -   Evolve `kannadi` into the `gilma` client.
    -   Instead of copying files to a local replica directory, it will send them over the network to the `gilma-server`.
    -   The client will need a new command structure (e.g., `gilma push <directory>`).
    -   It will first send a list of files and their metadata (the "plan").
    -   Then, it will send the content of the files the server needs.

**Completion of Phase 1:** You will be able to run `gilma push ./my_project` and see the files appear on the server.

---

### Phase 2: The `pull` Command & Server Intelligence

**Goal:** Get files from the server back to a client.

1.  **Server: The `list` command:**
    -   The server needs to be able to tell a client what files it has.
    -   It will respond to a "list" request from the client with its own `HashMap` of files and metadata.

2.  **Client: The `pull` Command:**
    -   Implement `gilma pull <directory>`.
    -   The client will first ask the server for its list of files.
    -   It will then perform the same 3-way comparison `kannadi` does (create, update, delete), but the "source" is now the server's list, and the "replica" is the local directory.
    -   It will then request the specific files it needs from the server.

**Completion of Phase 2:** You will be able to run `gilma pull ./empty_dir` and have it populated with the files from the server.

---

### Phase 3: Versioning with Content-Addressable Storage

**Goal:** Never lose history. Store snapshots instead of just mirroring. This is the core of Git's design.

1.  **Hashing:**
    -   Instead of identifying files by their path, we will identify them by the hash of their content (e.g., SHA-1).
    -   Files on the server will be stored in a directory structure based on their hash (e.g., `objects/ab/cdef123...`). This is how Git works.

2.  **Commits:**
    -   A "commit" will be a file that represents a snapshot of the directory at a point in time. It will be a list of file paths and their corresponding content hashes.
    -   The `push` command will no longer just send files; it will create a new "commit" object and send it.

3.  **Branches/Tags:**
    -   A "branch" will simply be a pointer, a file that contains the hash of the latest commit on that branch (e.g., the file `refs/heads/main` contains the hash of the last commit).

**Completion of Phase 3:** `gilma` will be a true, albeit simple, version control system.

---

This is the mountain you have chosen to climb. It is steep. Do not be discouraged. We will take it one step at a time.

Your lesson for today is over. When you return, we will begin Phase 1.

Dismissed.